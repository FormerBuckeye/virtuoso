
/*
 * Copyright 2007 Massachusetts Institute of Technology
 */

/**/

#ifndef __INFO_FLOW_H_
#define __INFO_FLOW_H_

#include "stdint.h"



#define USE_SENTINEL

void search_buf_for_pattern(char* buf,int len);

void push_key_label(char*);
void info_flow_label(unsigned long long, size_t,char*);
void info_flow_copy(unsigned long long, unsigned long long, size_t);

#define IF_MAX_KEYBOARD_LABEL_LEN 1024
#define IF_MAX_NETWORK_LABEL_LEN 2048

typedef unsigned char u_char;
typedef uint8_t trl_boolean;


// an info-flow op
typedef uint32_t if_op_t;
// an arg to an info-flow op
typedef uint32_t if_arg_t;
// an address used by an info-flow op
typedef unsigned long long if_addr_t;
// the number of the register this info-flow op uses
typedef u_char if_regnum_t;
// memory suffix index number (kernel, user, etc)
typedef u_char if_memsuffixnum_t;
// ?
typedef u_char if_shift_t;
// ?
typedef u_char if_mem_write_t;

#define ONE_MILLION 1048576
#define IF_LOG_SIZE ONE_MILLION * 100

// used to signal a value is uninit.  not very safe.  
#define UNINITIALIZED 255

//we're pretending that real memeory,registers,io_buffer,and the hard drive are all in one continuous block of memory
//first is physical memory, then registers, then io_buffer, then hd
//define the start of io_buffer to be phys_ram_size + size of registers
#define IO_BUFFER_BASE_ADDR phys_ram_size + 16*8
//define the start of hd to be phys_ram_size + size of registers + size of io_buffer
#define HD_BASE_ADDR IO_BUFFER_BASE_ADDR + 16*512+4

//declare this here for target-i386/ops_template.h
//QEMU will try very hard to map emulated registers to real ones.  We can't take the
// address of a register.  So we use fake registers for the info-flow graph.

// an array of addresses, all fake.
extern unsigned long long ifregaddr[];


// pointer to current place in info-flow log
extern char *if_log_ptr;           
// pointer to base of info-flow log
extern char *if_log_base;         
// length of info-flow log in bytes  
extern uint32_t if_log_len;
// used to turn info-flow on (or off)
extern trl_boolean if_on;
// flag -- log info-flow but discard (for timing)
extern trl_boolean if_log_only;
// 
extern uint32_t if_debug;
extern trl_boolean if_save_log;
extern trl_boolean if_count_ops;
extern uint32_t if_log_rollup_ind;     
extern uint32_t if_log_rollup_len;  

extern uint32_t if_keyboard_label_ind_next;
extern trl_boolean if_keyboard_label_changed;
extern uint32_t if_debug_high_counter;
extern char *if_keyboard_label;

extern trl_boolean if_network_label_changed;
extern char *if_network_label;

extern int phys_ram_size;

char *if_move_log_ptr(uint32_t dist);
void if_log_new_keyboard_label(void);


/*
  The structure of a single info-flow log entry is this.

  First byte represents the info flow operation, if_op, which is one of
  the 230-some possibilities in this enum type.  Note that currently we
  pack this into a 4-byte unsigned int.  

  Second byte used to represent three parameterizations.  We'll never need all 
  three at the same time, so we have just one, if_param.  So it's like a C-union. 
  In practice, it can take on somewhat less than 256 values, so we only need one byte for it.
  More details follow on the three possible parameterizations. 

  PARAMETERIZATION 1. Value of REG macro, defined multiple times in op.c 
  for each inclusion of opreg_template.h.  There are eight possible values:
  REG={EAX, ECX, EDX, EBX, ESP, EBP, ESI, EDI}, which are translated into
  a number REGNUM=0..7 in opreg_template.h.
  Actually, if we were handling all the 64-bit reg there would be a total of 
  16 registers.  We're taking a raincheck on 64-bit for now.  But we'll need 
  at most 4 bits for this.  

  PARAMETERIZATION 2. Value of MEMSUFFIX macro, defined in op.c multiple times, 
  again for multiple includes, this time of ops_mem.h  There are three possible
  values, MEMSUFFIX={_raw,_kernel,_user}, which are translated in ops_mem.h into 
  a number MEMSUFFIXNUM=0..2.  
  Thus, we need 2 bits to represent this value.  

  PARAMETERIZATION 3.  This one has two parts. 
  PART 1. Value of SHIFT macro, defined multiple times in op.c 
  for each inclusion of ops_template.h.  There are four possible values, 0..3.
  No need to translate into a number.  We need at most 2 bits for this one. 
  PART 2. Value of MEM_WRITE macro, defined multiple times in ops_template.h,
  for each inclusion of ops_template_mem.h.  Four possibilities, 
  MEM_WRITE={undef,0,1,2} where "undef" means not defined. 
  Thus, we'll need 2 bits for this.  Because op.c includes ops_template.h 
  which, in turn, includes ops_template_mem.h, we need to represent both
  SHIFT and MEM_WRITE in the info-flow log.  So 4 bits total.
*/



// mapping from register name to number
#define IFRN_EAX 0
#define IFRN_ECX 1
#define IFRN_EDX 2
#define IFRN_EBX 3
#define IFRN_ESP 4
#define IFRN_EBP 5
#define IFRN_ESI 6
#define IFRN_EDI 7
#define IFRN_T0 8
#define IFRN_T1 9
#define IFRN_A0 10
#define IFRN_Q0 11
#define IFRN_Q1 11
#define IFRN_Q2 12
#define IFRN_Q3 13
#define IFRN_Q4 14



// Don't edit this by hand.  Autogenerate with target-i386/create_if_ops.pl

typedef enum info_flow_op_enum {
INFO_FLOW_OP_AAA,
INFO_FLOW_OP_AAD,
INFO_FLOW_OP_AAM,
INFO_FLOW_OP_AAS,
INFO_FLOW_OP_ADDL_A0_AL,
INFO_FLOW_OP_ADDL_A0_IM,
INFO_FLOW_OP_ADDL_A0_SS,
INFO_FLOW_OP_ADDL_EDI_T0,
INFO_FLOW_OP_ADDL_ESI_T0,
INFO_FLOW_OP_ADDL_ESP_2,
INFO_FLOW_OP_ADDL_ESP_4,
INFO_FLOW_OP_ADDL_ESP_IM,
INFO_FLOW_OP_ADDL_T0_IM,
INFO_FLOW_OP_ADDL_T0_T1,
INFO_FLOW_OP_ADDL_T1_IM,
INFO_FLOW_OP_ADDR_ADDL_A0_SEG,
INFO_FLOW_OP_ADDR_MOVL_A0_SEG,
INFO_FLOW_OP_ADDR_MOVL_ENV_T0,
INFO_FLOW_OP_ADDR_MOVL_ENV_T1,
INFO_FLOW_OP_ADDR_MOVL_T0_ENV,
INFO_FLOW_OP_ADDR_MOVTL_ENV_T0,
INFO_FLOW_OP_ADDR_MOVTL_ENV_T1,
INFO_FLOW_OP_ADDR_MOVTL_T0_ENV,
INFO_FLOW_OP_ADDR_MOVTL_T1_ENV,
INFO_FLOW_OP_ADDW_EDI_T0,
INFO_FLOW_OP_ADDW_ESI_T0,
INFO_FLOW_OP_ADDW_ESP_2,
INFO_FLOW_OP_ADDW_ESP_4,
INFO_FLOW_OP_ADDW_ESP_IM,
INFO_FLOW_OP_ANDL_A0_FFFF,
INFO_FLOW_OP_ANDL_T0_FFFF,
INFO_FLOW_OP_ANDL_T0_IM,
INFO_FLOW_OP_ANDL_T0_T1,
INFO_FLOW_OP_ARPL,
INFO_FLOW_OP_BSWAPL_T0,
INFO_FLOW_OP_CLTS,
INFO_FLOW_OP_CMPXCHG8B_PART1,
INFO_FLOW_OP_CMPXCHG8B_PART2,
INFO_FLOW_OP_CPUID,
INFO_FLOW_OP_DAA,
INFO_FLOW_OP_DAS,
INFO_FLOW_OP_DECL_ECX,
INFO_FLOW_OP_DECL_T0,
INFO_FLOW_OP_DECW_ECX,
INFO_FLOW_OP_DIVB_AL_T0,
INFO_FLOW_OP_DIVL_EAX_T0,
INFO_FLOW_OP_DIVW_AX_T0,
INFO_FLOW_OP_ENTER_LEVEL,
INFO_FLOW_OP_FNSTSW_EAX,
INFO_FLOW_OP_IDIVB_AL_T0,
INFO_FLOW_OP_IDIVL_EAX_T0,
INFO_FLOW_OP_IDIVW_AX_T0,
INFO_FLOW_OP_IMULB_AL_T0,
INFO_FLOW_OP_IMULL_EAX_T0,
INFO_FLOW_OP_IMULL_T0_T1,
INFO_FLOW_OP_IMULW_AX_T0,
INFO_FLOW_OP_IMULW_T0_T1,
INFO_FLOW_OP_INCL_T0,
INFO_FLOW_OP_INVLPG_A0,
INFO_FLOW_OP_IRET_PROTECTED,
INFO_FLOW_OP_IRET_REAL,
INFO_FLOW_OP_JMP_T0,
INFO_FLOW_OP_LAR,
INFO_FLOW_OP_LCALL_PROTECTED_T0_T1,
INFO_FLOW_OP_LCALL_REAL_T0_T1,
INFO_FLOW_OP_LJMP_PROTECTED_T0_T1,
INFO_FLOW_OP_LLDT_T0,
INFO_FLOW_OP_LMSW_T0,
INFO_FLOW_OP_LRET_PROTECTED,
INFO_FLOW_OP_LSL,
INFO_FLOW_OP_LTR_T0,
INFO_FLOW_OP_MEMSUFFIX_ADDR_LDL_T0_A0,
INFO_FLOW_OP_MEMSUFFIX_ADDR_LDL_T1_A0,
INFO_FLOW_OP_MEMSUFFIX_ADDR_LDSB_T0_A0,
INFO_FLOW_OP_MEMSUFFIX_ADDR_LDSB_T1_A0,
INFO_FLOW_OP_MEMSUFFIX_ADDR_LDSW_T0_A0,
INFO_FLOW_OP_MEMSUFFIX_ADDR_LDSW_T1_A0,
INFO_FLOW_OP_MEMSUFFIX_ADDR_LDUB_T0_A0,
INFO_FLOW_OP_MEMSUFFIX_ADDR_LDUB_T1_A0,
INFO_FLOW_OP_MEMSUFFIX_ADDR_LDUW_T0_A0,
INFO_FLOW_OP_MEMSUFFIX_ADDR_LDUW_T1_A0,
INFO_FLOW_OP_MEMSUFFIX_ADDR_STB_T0_A0,
INFO_FLOW_OP_MEMSUFFIX_ADDR_STL_T0_A0,
INFO_FLOW_OP_MEMSUFFIX_ADDR_STL_T1_A0,
INFO_FLOW_OP_MEMSUFFIX_ADDR_STW_T0_A0,
INFO_FLOW_OP_MEMSUFFIX_ADDR_STW_T1_A0,
INFO_FLOW_OP_MOVB_EFLAGS_T0,
INFO_FLOW_OP_MOVL_A0_IM,
INFO_FLOW_OP_MOVL_CRN_T0,
INFO_FLOW_OP_MOVL_DRN_T0,
INFO_FLOW_OP_MOVL_EFLAGS_T0,
INFO_FLOW_OP_MOVL_EFLAGS_T0_CPL0,
INFO_FLOW_OP_MOVL_EFLAGS_T0_IO,
INFO_FLOW_OP_MOVL_EIP_IM,
INFO_FLOW_OP_MOVL_SEG_T0,
INFO_FLOW_OP_MOVL_SEG_T0_VM,
INFO_FLOW_OP_MOVL_T0_0,
INFO_FLOW_OP_MOVL_T0_EFLAGS,
INFO_FLOW_OP_MOVL_T0_IM,
INFO_FLOW_OP_MOVL_T0_IMU,
INFO_FLOW_OP_MOVL_T0_SEG,
INFO_FLOW_OP_MOVL_T0_T1,
INFO_FLOW_OP_MOVL_T1_A0,
INFO_FLOW_OP_MOVL_T1_IM,
INFO_FLOW_OP_MOVL_T1_IMU,
INFO_FLOW_OP_MOVSBL_T0_T0,
INFO_FLOW_OP_MOVSBW_AX_AL,
INFO_FLOW_OP_MOVSLQ_EDX_EAX,
INFO_FLOW_OP_MOVSWL_DX_AX,
INFO_FLOW_OP_MOVSWL_EAX_AX,
INFO_FLOW_OP_MOVSWL_T0_T0,
INFO_FLOW_OP_MOVTL_T0_CR8,
INFO_FLOW_OP_MOVW_EFLAGS_T0,
INFO_FLOW_OP_MOVW_EFLAGS_T0_CPL0,
INFO_FLOW_OP_MOVW_EFLAGS_T0_IO,
INFO_FLOW_OP_MOVZBL_T0_T0,
INFO_FLOW_OP_MOVZWL_T0_T0,
INFO_FLOW_OP_MOV_T0_CC,
INFO_FLOW_OP_MULB_AL_T0,
INFO_FLOW_OP_MULL_EAX_T0,
INFO_FLOW_OP_MULW_AX_T0,
INFO_FLOW_OP_NEGL_T0,
INFO_FLOW_OP_NOTL_T0,
INFO_FLOW_OP_ORL_T0_T1,
INFO_FLOW_OP_RDMSR,
INFO_FLOW_OP_RDTSC,
INFO_FLOW_OP_REG_ADDL_A0_R,
INFO_FLOW_OP_REG_ADDL_A0_R_S1,
INFO_FLOW_OP_REG_ADDL_A0_R_S2,
INFO_FLOW_OP_REG_ADDL_A0_R_S3,
INFO_FLOW_OP_REG_CMOVL_R_T1_T0,
INFO_FLOW_OP_REG_CMOVW_R_T1_T0,
INFO_FLOW_OP_REG_MOVB_R_T0,
INFO_FLOW_OP_REG_MOVB_R_T1,
INFO_FLOW_OP_REG_MOVH_R_T0,
INFO_FLOW_OP_REG_MOVH_R_T1,
INFO_FLOW_OP_REG_MOVH_T0_R,
INFO_FLOW_OP_REG_MOVH_T1_R,
INFO_FLOW_OP_REG_MOVL_A0_R,
INFO_FLOW_OP_REG_MOVL_R_A0,
INFO_FLOW_OP_REG_MOVL_R_T0,
INFO_FLOW_OP_REG_MOVL_R_T1,
INFO_FLOW_OP_REG_MOVL_T0_R,
INFO_FLOW_OP_REG_MOVL_T1_R,
INFO_FLOW_OP_REG_MOVW_R_A0,
INFO_FLOW_OP_REG_MOVW_R_T0,
INFO_FLOW_OP_REG_MOVW_R_T1,
INFO_FLOW_OP_SALC,
INFO_FLOW_OP_SETBE_T0_CC,
INFO_FLOW_OP_SETB_T0_CC,
INFO_FLOW_OP_SETLE_T0_CC,
INFO_FLOW_OP_SETL_T0_CC,
INFO_FLOW_OP_SETO_T0_CC,
INFO_FLOW_OP_SETP_T0_CC,
INFO_FLOW_OP_SETS_T0_CC,
INFO_FLOW_OP_SETZ_T0_CC,
INFO_FLOW_OP_SHIFT_ADD_BIT_A0_T1,
INFO_FLOW_OP_SHIFT_BSF_T0_CC,
INFO_FLOW_OP_SHIFT_BSR_T0_CC,
INFO_FLOW_OP_SHIFT_BTC_T0_T1_CC,
INFO_FLOW_OP_SHIFT_BTR_T0_T1_CC,
INFO_FLOW_OP_SHIFT_BTS_T0_T1_CC,
INFO_FLOW_OP_SHIFT_IN_DX_T0,
INFO_FLOW_OP_SHIFT_IN_T0_T1,
INFO_FLOW_OP_SHIFT_MEM_WRITE_ADC_T0_T1_CC,
INFO_FLOW_OP_SHIFT_MEM_WRITE_CMPXCHG_T0_T1_EAX_CC,
INFO_FLOW_OP_SHIFT_MEM_WRITE_RCL_T0_T1_CC,
INFO_FLOW_OP_SHIFT_MEM_WRITE_RCR_T0_T1_CC,
INFO_FLOW_OP_SHIFT_MEM_WRITE_ROL_T0_T1,
INFO_FLOW_OP_SHIFT_MEM_WRITE_ROL_T0_T1_CC,
INFO_FLOW_OP_SHIFT_MEM_WRITE_ROR_T0_T1,
INFO_FLOW_OP_SHIFT_MEM_WRITE_ROR_T0_T1_CC,
INFO_FLOW_OP_SHIFT_MEM_WRITE_SAR_T0_T1_CC,
INFO_FLOW_OP_SHIFT_MEM_WRITE_SBB_T0_T1_CC,
INFO_FLOW_OP_SHIFT_MEM_WRITE_SHLD_T0_T1_ECX_CC,
INFO_FLOW_OP_SHIFT_MEM_WRITE_SHLD_T0_T1_IM_CC,
INFO_FLOW_OP_SHIFT_MEM_WRITE_SHL_T0_T1_CC,
INFO_FLOW_OP_SHIFT_MEM_WRITE_SHRD_T0_T1_ECX_CC,
INFO_FLOW_OP_SHIFT_MEM_WRITE_SHRD_T0_T1_IM_CC,
INFO_FLOW_OP_SHIFT_MEM_WRITE_SHR_T0_T1_CC,
INFO_FLOW_OP_SHIFT_MOVL_T0_DSHIFT,
INFO_FLOW_OP_SHIFT_SAR_T0_T1,
INFO_FLOW_OP_SHIFT_SETBE_T0_SUB,
INFO_FLOW_OP_SHIFT_SETB_T0_SUB,
INFO_FLOW_OP_SHIFT_SETLE_T0_SUB,
INFO_FLOW_OP_SHIFT_SETL_T0_SUB,
INFO_FLOW_OP_SHIFT_SETS_T0_SUB,
INFO_FLOW_OP_SHIFT_SETZ_T0_SUB,
INFO_FLOW_OP_SHIFT_SHL_T0_T1,
INFO_FLOW_OP_SHIFT_SHR_T0_T1,
INFO_FLOW_OP_SUBL_A0_2,
INFO_FLOW_OP_SUBL_A0_4,
INFO_FLOW_OP_SUBL_T0_T1,
INFO_FLOW_OP_SYSENTER,
INFO_FLOW_OP_SYSEXIT,
INFO_FLOW_OP_WRMSR,
INFO_FLOW_OP_XORL_T0_T1,
INFO_FLOW_OP_XOR_T0_1,
INFO_FLOW_OP_KEYBOARD_INPUT,
INFO_FLOW_OP_NEW_KEYBOARD_LABEL,
INFO_FLOW_OP_NEW_NETWORK_LABEL,
INFO_FLOW_OP_NETWORK_INPUT_BYTE_T0,
INFO_FLOW_OP_NETWORK_INPUT_WORD_T0,
INFO_FLOW_OP_NETWORK_INPUT_LONG_T0,
INFO_FLOW_OP_NETWORK_INPUT_BYTE_T1,
INFO_FLOW_OP_NETWORK_INPUT_WORD_T1,
INFO_FLOW_OP_NETWORK_INPUT_LONG_T1,
INFO_FLOW_OP_NETWORK_OUTPUT_BYTE_T0,
INFO_FLOW_OP_NETWORK_OUTPUT_WORD_T0,
INFO_FLOW_OP_NETWORK_OUTPUT_LONG_T0,
INFO_FLOW_OP_NETWORK_OUTPUT_BYTE_T1,
INFO_FLOW_OP_NETWORK_OUTPUT_WORD_T1,
INFO_FLOW_OP_NETWORK_OUTPUT_LONG_T1,
INFO_FLOW_OP_HD_TRANSFER,
INFO_FLOW_OP_HD_TRANSFER_PART1,
INFO_FLOW_OP_HD_TRANSFER_PART2,
INFO_FLOW_OP_MMU_PHYS_ADDR_DIRECT_LDQ,
INFO_FLOW_OP_MMU_PHYS_ADDR_DIRECT_LDL,
INFO_FLOW_OP_MMU_PHYS_ADDR_DIRECT_LDW,
INFO_FLOW_OP_MMU_PHYS_ADDR_DIRECT_LDB,
INFO_FLOW_OP_MMU_PHYS_ADDR_IO_ALIGNED_LDQ,
INFO_FLOW_OP_MMU_PHYS_ADDR_IO_ALIGNED_LDL,
INFO_FLOW_OP_MMU_PHYS_ADDR_IO_ALIGNED_LDW,
INFO_FLOW_OP_MMU_PHYS_ADDR_IO_ALIGNED_LDB,
INFO_FLOW_OP_MMU_PHYS_ADDR_UNALIGNED_SAME_PAGE_LDQ,
INFO_FLOW_OP_MMU_PHYS_ADDR_UNALIGNED_SAME_PAGE_LDL,
INFO_FLOW_OP_MMU_PHYS_ADDR_UNALIGNED_SAME_PAGE_LDB,
INFO_FLOW_OP_MMU_PHYS_ADDR_UNALIGNED_SAME_PAGE_LDW,
INFO_FLOW_OP_MMU_PHYS_ADDR_UNALIGNED_DIFFERENT_PAGE_PART1_LDQ,
INFO_FLOW_OP_MMU_PHYS_ADDR_UNALIGNED_DIFFERENT_PAGE_PART1_LDL,
INFO_FLOW_OP_MMU_PHYS_ADDR_UNALIGNED_DIFFERENT_PAGE_PART1_LDW,
INFO_FLOW_OP_MMU_PHYS_ADDR_UNALIGNED_DIFFERENT_PAGE_PART1_LDB,
INFO_FLOW_OP_MMU_PHYS_ADDR_UNALIGNED_DIFFERENT_PAGE_PART2_LDQ,
INFO_FLOW_OP_MMU_PHYS_ADDR_UNALIGNED_DIFFERENT_PAGE_PART2_LDL,
INFO_FLOW_OP_MMU_PHYS_ADDR_UNALIGNED_DIFFERENT_PAGE_PART2_LDB,
INFO_FLOW_OP_MMU_PHYS_ADDR_UNALIGNED_DIFFERENT_PAGE_PART2_LDW,
INFO_FLOW_OP_MMU_PHYS_ADDR_UNALIGNED_DIFFERENT_PAGE_IO_PART2_LDQ,
INFO_FLOW_OP_MMU_PHYS_ADDR_UNALIGNED_DIFFERENT_PAGE_IO_PART2_LDL,
INFO_FLOW_OP_MMU_PHYS_ADDR_UNALIGNED_DIFFERENT_PAGE_IO_PART2_LDB,
INFO_FLOW_OP_MMU_PHYS_ADDR_UNALIGNED_DIFFERENT_PAGE_IO_PART2_LDW,
INFO_FLOW_OP_MMU_PHYS_ADDR_DIRECT_STQ,
INFO_FLOW_OP_MMU_PHYS_ADDR_DIRECT_STL,
INFO_FLOW_OP_MMU_PHYS_ADDR_DIRECT_STW,
INFO_FLOW_OP_MMU_PHYS_ADDR_DIRECT_STB,
INFO_FLOW_OP_MMU_PHYS_ADDR_IO_ALIGNED_STQ,
INFO_FLOW_OP_MMU_PHYS_ADDR_IO_ALIGNED_STL,
INFO_FLOW_OP_MMU_PHYS_ADDR_IO_ALIGNED_STW,
INFO_FLOW_OP_MMU_PHYS_ADDR_IO_ALIGNED_STB,
INFO_FLOW_OP_MMU_PHYS_ADDR_UNALIGNED_SAME_PAGE_STQ,
INFO_FLOW_OP_MMU_PHYS_ADDR_UNALIGNED_SAME_PAGE_STL,
INFO_FLOW_OP_MMU_PHYS_ADDR_UNALIGNED_SAME_PAGE_STB,
INFO_FLOW_OP_MMU_PHYS_ADDR_UNALIGNED_SAME_PAGE_STW,
INFO_FLOW_OP_MMU_PHYS_ADDR_UNALIGNED_DIFFERENT_PAGE_PART1_STQ,
INFO_FLOW_OP_MMU_PHYS_ADDR_UNALIGNED_DIFFERENT_PAGE_PART1_STL,
INFO_FLOW_OP_MMU_PHYS_ADDR_UNALIGNED_DIFFERENT_PAGE_PART1_STW,
INFO_FLOW_OP_MMU_PHYS_ADDR_UNALIGNED_DIFFERENT_PAGE_PART1_STB,
INFO_FLOW_OP_MMU_PHYS_ADDR_UNALIGNED_DIFFERENT_PAGE_PART2_STQ,
INFO_FLOW_OP_MMU_PHYS_ADDR_UNALIGNED_DIFFERENT_PAGE_PART2_STL,
INFO_FLOW_OP_MMU_PHYS_ADDR_UNALIGNED_DIFFERENT_PAGE_PART2_STB,
INFO_FLOW_OP_MMU_PHYS_ADDR_UNALIGNED_DIFFERENT_PAGE_PART2_STW,
INFO_FLOW_OP_MMU_PHYS_ADDR_UNALIGNED_DIFFERENT_PAGE_IO_PART2_STQ,
INFO_FLOW_OP_MMU_PHYS_ADDR_UNALIGNED_DIFFERENT_PAGE_IO_PART2_STL,
INFO_FLOW_OP_MMU_PHYS_ADDR_UNALIGNED_DIFFERENT_PAGE_IO_PART2_STB,
INFO_FLOW_OP_MMU_PHYS_ADDR_UNALIGNED_DIFFERENT_PAGE_IO_PART2_STW,
INFO_FLOW_OP_X86_INSN,
INFO_FLOW_OP_CMPXCHG_T0_T1_EAX_CC_CASE1,
INFO_FLOW_OP_CMPXCHG_T0_T1_EAX_CC_CASE2,
INFO_FLOW_OP_CMPXCHG_T0_T1_EAX_CC_CASE3,
INFO_FLOW_OP_SAVE_REG,
INFO_FLOW_OP_RESTORE_REG,
INFO_FLOW_OP_CPU_READ_ADDR,
INFO_FLOW_OP_CPU_WRITE_ADDR,
INFO_FLOW_OP_TLB_FILL,
INFO_FLOW_OP_SAVE_ENV,
INFO_FLOW_OP_RESTORE_ENV,
INFO_FLOW_OP_WRITE_CURRENT_PID,
INFO_FLOW_OP_WRITE_CURRENT_UID,
INFO_FLOW_OP_SET_CPL,

// system calls 
INFO_FLOW_OP_SYS_NI_SYSCALL,
INFO_FLOW_OP_SYS_EXIT,
INFO_FLOW_OP_SYS_FORK,
INFO_FLOW_OP_SYS_READ,
INFO_FLOW_OP_SYS_WRITE,
INFO_FLOW_OP_SYS_OPEN,
INFO_FLOW_OP_SYS_CLOSE,
INFO_FLOW_OP_SYS_WAITPID,
INFO_FLOW_OP_SYS_CREAT,
INFO_FLOW_OP_SYS_UNLINK,
INFO_FLOW_OP_SYS_CHDIR,
INFO_FLOW_OP_SYS_TIME,
INFO_FLOW_OP_SYS_MKNOD,
INFO_FLOW_OP_SYS_CHMOD,
INFO_FLOW_OP_SYS_LCHOWN16,
INFO_FLOW_OP_SYS_NI_SYSCALL,
INFO_FLOW_OP_SYS_STAT,
INFO_FLOW_OP_SYS_LSEEK,
INFO_FLOW_OP_SYS_GETPID,
INFO_FLOW_OP_SYS_OLDUMOUNT,
INFO_FLOW_OP_SYS_SETUID16,
INFO_FLOW_OP_SYS_GETUID16,
INFO_FLOW_OP_SYS_STIME,
INFO_FLOW_OP_SYS_PTRACE,
INFO_FLOW_OP_SYS_ALARM,
INFO_FLOW_OP_SYS_FSTAT,
INFO_FLOW_OP_SYS_PAUSE,
INFO_FLOW_OP_SYS_UTIME,
INFO_FLOW_OP_SYS_NI_SYSCALL,
INFO_FLOW_OP_SYS_NI_SYSCALL,
INFO_FLOW_OP_SYS_ACCESS,
INFO_FLOW_OP_SYS_NICE,
INFO_FLOW_OP_SYS_NI_SYSCALL,
INFO_FLOW_OP_SYS_SYNC,
INFO_FLOW_OP_SYS_KILL,
INFO_FLOW_OP_SYS_TIMES,
INFO_FLOW_OP_SYS_NI_SYSCALL,
INFO_FLOW_OP_SYS_BREAK,
INFO_FLOW_OP_SYS_SETGID16,
INFO_FLOW_OP_SYS_GETGID16,
INFO_FLOW_OP_SYS_SIGNAL,
INFO_FLOW_OP_SYS_GETEUID16,
INFO_FLOW_OP_SYS_GETEGID16,
INFO_FLOW_OP_SYS_ACCT,
INFO_FLOW_OP_SYS_UMOUNT2,
INFO_FLOW_OP_SYS_LOCK,
INFO_FLOW_OP_SYS_IOCTL,
INFO_FLOW_OP_SYS_FCNTL,
INFO_FLOW_OP_SYS_MPX,
INFO_FLOW_OP_SYS_SETPGID,
INFO_FLOW_OP_SYS_ULIMIT,
INFO_FLOW_OP_SYS_OLDOLDUNAME,
INFO_FLOW_OP_SYS_UMASK,
INFO_FLOW_OP_SYS_CHROOT,
INFO_FLOW_OP_SYS_USTAT,
INFO_FLOW_OP_SYS_DUP2,
INFO_FLOW_OP_SYS_GETPPID,
INFO_FLOW_OP_SYS_GETPGRP,
INFO_FLOW_OP_SYS_SETSID,
INFO_FLOW_OP_SYS_SIGACTION,
INFO_FLOW_OP_SYS_SGETMASK,
INFO_FLOW_OP_SYS_SSETMASK,
INFO_FLOW_OP_SYS_SETREUID,
INFO_FLOW_OP_SYS_SETREGID,
INFO_FLOW_OP_SYS_SIGSUSPEND,
INFO_FLOW_OP_SYS_SIGPENDING,
INFO_FLOW_OP_SYS_SETHOSTNAME,
INFO_FLOW_OP_SYS_SETRLIMIT,
INFO_FLOW_OP_SYS_GETRLIMIT,
INFO_FLOW_OP_SYS_GETRUSAGE,
INFO_FLOW_OP_SYS_GETTIMEOFDAY,
INFO_FLOW_OP_SYS_SETTIMEOFDAY,
INFO_FLOW_OP_SYS_GETGROUPS,
INFO_FLOW_OP_SYS_SETGROUPS,
INFO_FLOW_OP_SYS_SELECT,
INFO_FLOW_OP_SYS_SYMLINK,
INFO_FLOW_OP_SYS_OLDLSTAT,
INFO_FLOW_OP_SYS_READLINK,
INFO_FLOW_OP_SYS_USELIB,
INFO_FLOW_OP_SYS_SWAPON,
INFO_FLOW_OP_SYS_REBOOT,
INFO_FLOW_OP_SYS_READDIR,
INFO_FLOW_OP_SYS_MMAP,
INFO_FLOW_OP_SYS_MUNMAP,
INFO_FLOW_OP_SYS_TRUNCATE,
INFO_FLOW_OP_SYS_FTRUNCATE,
INFO_FLOW_OP_SYS_FCHMOD,
INFO_FLOW_OP_SYS_FCHOWN,
INFO_FLOW_OP_SYS_GETPRIORITY,
INFO_FLOW_OP_SYS_SETPRIORITY,
INFO_FLOW_OP_SYS_PROFIL,
INFO_FLOW_OP_SYS_STATFS,
INFO_FLOW_OP_SYS_FSTATFS,
INFO_FLOW_OP_SYS_IOPERM,
INFO_FLOW_OP_SYS_SOCKETCALL,
INFO_FLOW_OP_SYS_SYSLOG,
INFO_FLOW_OP_SYS_SETITIMER,
INFO_FLOW_OP_SYS_GETITIMER,
INFO_FLOW_OP_SYS_STAT,
INFO_FLOW_OP_SYS_LSTAT,
INFO_FLOW_OP_SYS_FSTAT,
INFO_FLOW_OP_SYS_OLDUNAME,
INFO_FLOW_OP_SYS_IOPL,
INFO_FLOW_OP_SYS_VHANGUP,
INFO_FLOW_OP_SYS_IDLE,
INFO_FLOW_OP_SYS_VM86OLD,
INFO_FLOW_OP_SYS_WAIT4,
INFO_FLOW_OP_SYS_SWAPOFF,
INFO_FLOW_OP_SYS_SYSINFO,
INFO_FLOW_OP_SYS_IPC,
INFO_FLOW_OP_SYS_FSYNC,
INFO_FLOW_OP_SYS_SIGRETURN,
INFO_FLOW_OP_SYS_CLONE,
INFO_FLOW_OP_SYS_SETDOMAINNAME,
INFO_FLOW_OP_SYS_UNAME,
INFO_FLOW_OP_SYS_MODIFY_LDT,
INFO_FLOW_OP_SYS_ADJTIMEX,
INFO_FLOW_OP_SYS_MPROTECT,
INFO_FLOW_OP_SYS_SIGPROCMASK,
INFO_FLOW_OP_SYS_CREATE_MODULE,
INFO_FLOW_OP_SYS_INIT_MODULE,
INFO_FLOW_OP_SYS_DELETE_MODULE,
INFO_FLOW_OP_SYS_GET_KERNEL_SYMS,
INFO_FLOW_OP_SYS_QUOTACTL,
INFO_FLOW_OP_SYS_GETPGID,
INFO_FLOW_OP_SYS_FCHDIR,
INFO_FLOW_OP_SYS_BDFLUSH,
INFO_FLOW_OP_SYS_SYSFS,
INFO_FLOW_OP_SYS_PERSONALITY,
INFO_FLOW_OP_SYS_AFS_SYSCALL,
INFO_FLOW_OP_SYS_SETFSUID,
INFO_FLOW_OP_SYS_SETFSGID,
INFO_FLOW_OP_SYS_GETDENTS,
INFO_FLOW_OP_SYS_FLOCK,
INFO_FLOW_OP_SYS_MSYNC,
INFO_FLOW_OP_SYS_READV,
INFO_FLOW_OP_SYS_WRITEV,
INFO_FLOW_OP_SYS_GETSID,
INFO_FLOW_OP_SYS_FDATASYNC,
INFO_FLOW_OP_SYS_MLOCK,
INFO_FLOW_OP_SYS_MUNLOCK,
INFO_FLOW_OP_SYS_MLOCKALL,
INFO_FLOW_OP_SYS_MUNLOCKALL,
INFO_FLOW_OP_SYS_SCHED_SETPARAM,
INFO_FLOW_OP_SYS_SCHED_GETPARAM,
INFO_FLOW_OP_SYS_SCHED_SETSCHEDULER,
INFO_FLOW_OP_SYS_SCHED_GETSCHEDULER,
INFO_FLOW_OP_SYS_SCHED_YIELD,
INFO_FLOW_OP_SYS_SCHED_GET_PRIORITY_MAX,
INFO_FLOW_OP_SYS_SCHED_GET_PRIORITY_MIN,
INFO_FLOW_OP_SYS_SCHED_RR_GET_INTERVAL,
INFO_FLOW_OP_SYS_NANOSLEEP,
INFO_FLOW_OP_SYS_MREMAP,
INFO_FLOW_OP_SYS_SETRESUID,
INFO_FLOW_OP_SYS_GETRESUID,
INFO_FLOW_OP_SYS_VM86,
INFO_FLOW_OP_SYS_QUERY_MODULE,
INFO_FLOW_OP_SYS_POLL,
INFO_FLOW_OP_SYS_NFSSERVCTL,
INFO_FLOW_OP_SYS_SETRESGID,
INFO_FLOW_OP_SYS_GETRESGID,
INFO_FLOW_OP_SYS_PRCTL,
INFO_FLOW_OP_SYS_RT_SIGRETURN,
INFO_FLOW_OP_SYS_RT_SIGACTION,
INFO_FLOW_OP_SYS_RT_SIGPROCMASK,
INFO_FLOW_OP_SYS_RT_SIGPENDING,
INFO_FLOW_OP_SYS_RT_SIGTIMEDWAIT,
INFO_FLOW_OP_SYS_RT_SIGQUEUEINFO,
INFO_FLOW_OP_SYS_RT_SIGSUSPEND,
INFO_FLOW_OP_SYS_PREAD64,
INFO_FLOW_OP_SYS_PWRITE64,
INFO_FLOW_OP_SYS_CHOWN,
INFO_FLOW_OP_SYS_GETCWD,
INFO_FLOW_OP_SYS_CAPGET,
INFO_FLOW_OP_SYS_CAPSET,
INFO_FLOW_OP_SYS_SIGALTSTACK,
INFO_FLOW_OP_SYS_SENDFILE,
INFO_FLOW_OP_SYS_GETPMSG,
INFO_FLOW_OP_SYS_PUTPMSG,
INFO_FLOW_OP_SYS_VFORK,
INFO_FLOW_OP_SYS_GETRLIMIT,
INFO_FLOW_OP_SYS_MMAP2,
INFO_FLOW_OP_SYS_TRUNCATE64,
INFO_FLOW_OP_SYS_FTRUNCATE64,
INFO_FLOW_OP_SYS_STAT64,
INFO_FLOW_OP_SYS_LSTAT64,
INFO_FLOW_OP_SYS_FSTAT64,
INFO_FLOW_OP_SYS_LCHOWN32,
INFO_FLOW_OP_SYS_GETUID32,
INFO_FLOW_OP_SYS_GETGID32,
INFO_FLOW_OP_SYS_GETEUID32,
INFO_FLOW_OP_SYS_GETEGID32,
INFO_FLOW_OP_SYS_SETREUID32,
INFO_FLOW_OP_SYS_SETREGID32,
INFO_FLOW_OP_SYS_GETGROUPS32,
INFO_FLOW_OP_SYS_SETGROUPS32,
INFO_FLOW_OP_SYS_FCHOWN32,
INFO_FLOW_OP_SYS_SETRESUID32,
INFO_FLOW_OP_SYS_GETRESUID32,
INFO_FLOW_OP_SYS_SETRESGID32,
INFO_FLOW_OP_SYS_GETRESGID32,
INFO_FLOW_OP_SYS_CHOWN32,
INFO_FLOW_OP_SYS_SETUID32,
INFO_FLOW_OP_SYS_SETGID32,
INFO_FLOW_OP_SYS_SETFSUID32,
INFO_FLOW_OP_SYS_SETFSGID32,
INFO_FLOW_OP_SYS_PIVOT_ROOT,
INFO_FLOW_OP_SYS_MINCORE,
INFO_FLOW_OP_SYS_MADVISE,
INFO_FLOW_OP_SYS_GETDENTS64,
INFO_FLOW_OP_SYS_FCNTL64,
INFO_FLOW_OP_SYS_GETTID,
INFO_FLOW_OP_SYS_READAHEAD,
INFO_FLOW_OP_SYS_SETXATTR,
INFO_FLOW_OP_SYS_LSETXATTR,
INFO_FLOW_OP_SYS_FSETXATTR,
INFO_FLOW_OP_SYS_GETXATTR,
INFO_FLOW_OP_SYS_LGETXATTR,
INFO_FLOW_OP_SYS_FGETXATTR,
INFO_FLOW_OP_SYS_LISTXATTR,
INFO_FLOW_OP_SYS_LLISTXATTR,
INFO_FLOW_OP_SYS_FLISTXATTR,
INFO_FLOW_OP_SYS_REMOVEXATTR,
INFO_FLOW_OP_SYS_LREMOVEXATTR,
INFO_FLOW_OP_SYS_FREMOVEXATTR,
INFO_FLOW_OP_SYS_TKILL,
INFO_FLOW_OP_SYS_SENDFILE64,
INFO_FLOW_OP_SYS_FUTEX,
INFO_FLOW_OP_SYS_SCHED_SETAFFINITY,
INFO_FLOW_OP_SYS_SCHED_GETAFFINITY,
INFO_FLOW_OP_SYS_SET_THREAD_AREA,
INFO_FLOW_OP_SYS_GET_THREAD_AREA,
INFO_FLOW_OP_SYS_IO_SETUP,
INFO_FLOW_OP_SYS_IO_DESTROY,
INFO_FLOW_OP_SYS_IO_GETEVENTS,
INFO_FLOW_OP_SYS_IO_SUBMIT,
INFO_FLOW_OP_SYS_IO_CANCEL,
INFO_FLOW_OP_SYS_FADVISE64,
INFO_FLOW_OP_SYS_EXIT_GROUP,
INFO_FLOW_OP_SYS_LOOKUP_DCOOKIE,
INFO_FLOW_OP_SYS_EPOLL_CREATE,
INFO_FLOW_OP_SYS_EPOLL_CTL,
INFO_FLOW_OP_SYS_EPOLL_WAIT,
INFO_FLOW_OP_SYS_REMAP_FILE_PAGES,
INFO_FLOW_OP_SYS_SET_TID_ADDRESS,
INFO_FLOW_OP_SYS_TIMER_CREATE,

DUMMY_LAST_OP
} info_flow_op_enum_t;


/**********************************************************************/

// moves the log pointer.  
#define MOVE_LOG_PTR(dist) if_log_ptr += dist;

/*
  The following macros are used to POPULATE the info-flow log 
  They are used in the following files in target-i386

  op.c
  ops_mem.h
  opreg_template.h
  ops_template.h
  ops_template_mem.h

  We probably *should* use them in ops_sse.h but we are so 
  totally punting on that for now...
*/

// standard wrapper to a bunch of info-flow operations.
// only do them if info-flow is turned on.


#define IFLW_PUT_UINT8_T(x) \
  *((uint8_t *)if_log_ptr) = (uint8_t) x; \
  MOVE_LOG_PTR(sizeof(uint8_t));
 
#define IFLW_PUT_UINT16_T(x) \
  *((uint16_t *)if_log_ptr) = (uint16_t) x; \
  MOVE_LOG_PTR(sizeof(uint16_t));
 
#define IFLW_PUT_UINT32_T(x) \
  *((uint32_t *)if_log_ptr) = (uint32_t) x; \
  MOVE_LOG_PTR(sizeof(uint32_t));
 
#define IFLW_PUT_UINT64_T(x) \
  *((uint64_t *)if_log_ptr) = (uint64_t) x; \
  MOVE_LOG_PTR(sizeof(uint64_t));
 


#define IFLW_PUT_BYTE(b) \
  *((unsigned char*)if_log_ptr) = (unsigned char) b; \
  MOVE_LOG_PTR(sizeof(unsigned char));

  
#define IFLW_PUT_SHORT(s) \
  *((unsigned short*)if_log_ptr) = (unsigned short) s; \
  MOVE_LOG_PTR(sizeof(unsigned short));

#define IFLW_PUT_WORD(w) \
  *((uint32_t*)if_log_ptr) = (uint32_t) w; \
  MOVE_LOG_PTR(sizeof(uint32_t));

#define IFLW_PUT_LONG_LONG(q) \
  *((unsigned long long *)if_log_ptr) = (unsigned long long) q;	\
  MOVE_LOG_PTR(sizeof(unsigned long long));

#define IFLW_PUT_QUAD IFLW_PUT_LONG_LONG 

#define IFLW_PUT_SIZE_ARG(size) \
  *((size_t *)if_log_ptr) = (size_t) size;	\
  MOVE_LOG_PTR(sizeof(size_t));





// write a string to the log 
// first, wrirte its length as a 32-bit int
// second, write each of its bytes.  
#define IFLW_PUT_STRING(str)	\
{				\
  int i;			\
  int n = strlen(str);		\
  IFLW_PUT_UINT32_T(n);		\
  for (i=0; i<n; i++) {		\
    IFLW_PUT_UINT8_T(str[i]);	\
  }				\
}						



#ifndef USE_SENTINEL 
#define IFLW_WRAPPER(stuff) stuff

#else
#define THE_SENTINEL 0x42424242
#define IFLW_WRAPPER(stuff)  \
IFLW_PUT_WORD(THE_SENTINEL); \
stuff	
#endif // USE_SENTINEL



//#define IFLW_WRAPPER(stuff)			
//if (if_on == TRUE) {				
//  if (if_log_ptr - if_log_base >= if_log_len) {	
//    if_log_rollup();					
//  }							
//  *((char *)if_log_ptr) = (char) 42;			
//  MOVE_LOG_PTR(sizeof(char));				
//  stuff						
//}

  


#define IFLW_PUT_OP(if_op) \
  IFLW_PUT_WORD(if_op)

  
#define IFLW_PUT_ARG(if_arg) \
  IFLW_PUT_WORD(if_arg)

#define IFLW_PUT_ADDR(if_addr) \
  *((char **)if_log_ptr) = (char *) if_addr;	\
  MOVE_LOG_PTR(sizeof(char *));


#define IFLW(op) \
IFLW_WRAPPER ( \
  IFLW_PUT_OP(glue(INFO_FLOW_OP_,op));	\
)

#define IFLW_ADDR(op,addr) \
IFLW_WRAPPER( \
  IFLW_PUT_OP(glue(INFO_FLOW_OP_ADDR_,op));	\
  IFLW_PUT_ADDR( (char *) addr);		\
)

void new_network_label_check();

#define IFLW_NETWORK_INPUT_BYTE_T0(val) \
new_network_label_check();  \
IFLW_WRAPPER ( \
  IFLW_PUT_OP(INFO_FLOW_OP_NETWORK_INPUT_BYTE_T0); \
  IFLW_PUT_WORD(val); \
)

#define IFLW_NETWORK_INPUT_BYTE_T1(val) \
new_network_label_check(); \
IFLW_WRAPPER ( \
  IFLW_PUT_OP(INFO_FLOW_OP_NETWORK_INPUT_BYTE_T1); \
  IFLW_PUT_WORD(val); \
)

#define IFLW_NETWORK_INPUT_WORD_T0(val) \
new_network_label_check();  \
IFLW_WRAPPER ( \
  IFLW_PUT_OP(INFO_FLOW_OP_NETWORK_INPUT_WORD_T0); \
  IFLW_PUT_WORD(val); \
)

#define IFLW_NETWORK_INPUT_WORD_T1(val) \
new_network_label_check(); \
IFLW_WRAPPER ( \
  IFLW_PUT_OP(INFO_FLOW_OP_NETWORK_INPUT_WORD_T1); \
  IFLW_PUT_WORD(val); \
)
  
#define IFLW_NETWORK_INPUT_LONG_T0(val) \
new_network_label_check(); \
IFLW_WRAPPER ( \
  IFLW_PUT_OP(INFO_FLOW_OP_NETWORK_INPUT_LONG_T0); \
  IFLW_PUT_WORD(val); \
)

#define IFLW_NETWORK_INPUT_LONG_T1(val) \
new_network_label_check(); \
IFLW_WRAPPER ( \
  IFLW_PUT_OP(INFO_FLOW_OP_NETWORK_INPUT_LONG_T1); \
  IFLW_PUT_WORD(val); \
)

#define IFLW_NETWORK_OUTPUT_BYTE_T0() \
IFLW_WRAPPER ( \
  IFLW_PUT_OP(INFO_FLOW_OP_NETWORK_OUTPUT_BYTE_T0); \
)

#define IFLW_NETWORK_OUTPUT_BYTE_T1() \
IFLW_WRAPPER ( \
  IFLW_PUT_OP(INFO_FLOW_OP_NETWORK_OUTPUT_BYTE_T1); \
)

#define IFLW_NETWORK_OUTPUT_WORD_T0() \
IFLW_WRAPPER ( \
  IFLW_PUT_OP(INFO_FLOW_OP_NETWORK_OUTPUT_WORD_T0); \
)

#define IFLW_NETWORK_OUTPUT_WORD_T1() \
IFLW_WRAPPER ( \
  IFLW_PUT_OP(INFO_FLOW_OP_NETWORK_OUTPUT_WORD_T1); \
)
  
#define IFLW_NETWORK_OUTPUT_LONG_T0() \
IFLW_WRAPPER ( \
  IFLW_PUT_OP(INFO_FLOW_OP_NETWORK_OUTPUT_LONG_T0); \
)

#define IFLW_NETWORK_OUTPUT_LONG_T1() \
IFLW_WRAPPER ( \
  IFLW_PUT_OP(INFO_FLOW_OP_NETWORK_OUTPUT_LONG_T1); \
)

#define IFLW_HD_TRANSFER(from,to,size) \
IFLW_WRAPPER ( \
  IFLW_PUT_OP(INFO_FLOW_OP_HD_TRANSFER); \
  IFLW_PUT_LONG_LONG(from); \
  IFLW_PUT_LONG_LONG(to); \
  IFLW_PUT_SIZE_ARG(size); \
)

#define IFLW_HD_TRANSFER_PART1(from) \
IFLW_WRAPPER ( \
  IFLW_PUT_OP(INFO_FLOW_OP_HD_TRANSFER_PART1); \
  IFLW_PUT_LONG_LONG(from); \
)

#define IFLW_HD_TRANSFER_PART2(to,size) \
IFLW_WRAPPER ( \
  IFLW_PUT_OP(INFO_FLOW_OP_HD_TRANSFER_PART2); \
  IFLW_PUT_LONG_LONG(to); \
  IFLW_PUT_SIZE_ARG(size); \
)

#define IFLW_CPU_READ_ADDR(addr) \
IFLW_WRAPPER ( \
  IFLW_PUT_OP(INFO_FLOW_OP_CPU_READ_ADDR); \
  IFLW_PUT_LONG_LONG(addr); \
)

#define IFLW_CPU_WRITE_ADDR(addr) \
IFLW_WRAPPER ( \
  IFLW_PUT_OP(INFO_FLOW_OP_CPU_WRITE_ADDR); \
  IFLW_PUT_LONG_LONG(addr); \
)


#define IFLW_X86_INSN(n) \
IFLW_WRAPPER ( \
   IFLW_PUT_OP(INFO_FLOW_OP_X86_INSN); \
   IFLW_PUT_WORD(n); \
)

#define IFLW_SAVE_REG(reg) \
IFLW_WRAPPER ( \
   IFLW_PUT_OP(INFO_FLOW_OP_SAVE_REG); \
   IFLW_PUT_WORD(reg); \
)

#define IFLW_RESTORE_REG(reg) \
IFLW_WRAPPER ( \
   IFLW_PUT_OP(INFO_FLOW_OP_RESTORE_REG); \
   IFLW_PUT_WORD(reg); \
)

// this is for hw/pckbd.c
// interrupt (byte, word, long?)
// addr is the interrupt vector number
// val is they keycode (or is it scancode?)
// Note that we also put the current keyboard label index in the log.  
// We need to put this in the log so we can reconstruct correct label for 
// this byte when rolling up the log.  
// dtbuf is a buffer containing date-time ala ctime
#define IFLW_KEYBOARD_INPUT(val) \
IFLW_WRAPPER ( \
  IFLW_PUT_OP(INFO_FLOW_OP_KEYBOARD_INPUT); \
  IFLW_PUT_WORD(val); \
)


#define IFLW_WRITE_CURRENT_PID(current_pid) \
IFLW_WRAPPER ( \
  IFLW_PUT_OP(INFO_FLOW_OP_WRITE_CURRENT_PID); \
  IFLW_PUT_UINT32_T(current_pid); \
)

#define IFLW_WRITE_CURRENT_UID(current_uid) \
IFLW_WRAPPER ( \
  IFLW_PUT_OP(INFO_FLOW_OP_WRITE_CURRENTUPID); \
  IFLW_PUT_UINT32_T(current_uid); \
)



#define IFLW_SET_CPL(cpl) \
IFLW_WRAPPER ( \
  IFLW_PUT_OP(INFO_FLOW_OP_SET_CPL); \
  IFLW_PUT_UINT32_T(cpl); \
)





///////////////////////////////////////////////////

// These are for reading the info-flow log

#define IFLR_UNSIGNED_CHAR(uc) \
  uc = *((unsigned char *) if_p); \
  if_p += sizeof(unsigned char);

#define IFLR_UNSIGNED_SHORT(us) \
  us = *((unsigned short *) if_p); \
  if_p += sizeof(unsigned short);

#define IFLR_UNSIGNED_INT(ui) \
  ui = *((uint32_t *) if_p); \
  if_p += sizeof(uint32_t);

#ifdef USE_SENTINEL
#define IFLR_PEEK_UNSIGNED_INT() \
  *((uint32_t *) (if_p+4))
#else
#define IFLR_PEEK_UNSIGNED_INT() \
  *((uint32_t *) (if_p))
#endif

#define IFLR_UNSIGNED_LONG_LONG(ull) \
  ull = *((unsigned long long *) if_p); \
  if_p += sizeof(unsigned long long);

#define IFLR_SIZE(size) \
  size = *((size_t *) if_p); \
  if_p += sizeof(size_t);


// read a pointer from the log 
#define IFLR_PTR(p) \
{ \
  uint64_t ull; \
  IFLR_UNSIGNED_LONG_LONG(ull); \
  p = ull; \
}

// might want to make this a char again -- 4 bytes is 3 more than we currently need.
#define IFLR_OP(if_op) IFLR_UNSIGNED_INT(if_op)

#define IFLR_PEEK_OP() IFLR_PEEK_UNSIGNED_INT()

// address of first byte of register with number rn
// NB: trying to make these addresses orthogonal to any that 
// we might encounter for a real process by sending them to 
// page 0.  
//#define IFRBA(rn) (char *) (((int) &(ifreg[rn])) - ((int) &(ifreg[0])))
#define IFRBA(rn) ifregaddr[rn]



void if_info_flow_on(void);
void if_info_flow_off(void);
void if_log_rollup(void);
void if_log_create(void);
void if_log_destroy(void);
void timer_reset (void);
double timer_time (void);


void if_debug_set(int l);
void if_set_keyboard_label(const char *label);
void if_stats(void);
void if_trace_keyboard_label(char *label);
void if_save_log_on(void);
void if_save_log_off(void);


#ifdef IF_TESTER
#define qemu_malloc malloc
#define qemu_strdup strdup
#define qemu_mallocz mallocz
#endif

#ifdef QAINT
#include <cstring>
#endif 


#define IF_DEBUG_OFF 0
#define IF_DEBUG_LOW 1
#define IF_DEBUG_MED 2
#define IF_DEBUG_HIGH 3
#define IF_DEBUG_OMG 4


#endif // __INFO_FLOW_H_ 
