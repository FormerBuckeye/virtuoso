#!/usr/bin/perl -w 


# set of types used to represent a string as a syscall arg.
my %syscallStringTypes = ('char __user *',
			  'const char *',
			  'const char __user *',
			  'unsigned char __user *');

# arg 1 of a syscall is EBX, arg 2 is ECX, etc.  
# after 6, it gets complicated.
my @syscallRegArgs = ("EBX", "ECX", "EDX", "ESI", "EDI", "EBP");

# read in all the syscall prototypes
open F, "./syscall-prototypes";
my $maxSyscallNum = 0;
my %syscall;
while (my $line = <F>) {
    chomp $line;
    my @foo = split ' ', $line;
    my $num = shift @foo;
    $syscall{$num} = {};
    $syscall{$num}{proto} = $line;
    if ($num > $maxSyscallNum) {
	$maxSyscallNum = $num;
    }
    my $rest = join ' ', @foo;
    my $rettype = shift @foo;
    if ($rettype eq "missing") {
	# we have no prototype for this syscall
	my $name = shift @foo;
	$syscall{$num}{name} = $name;
	$syscall{$num}{noargs} = 1;
    }
    elsif ($rest =~ /(.*)\s(.*)\((.*)\)/) {
	# we have a prototype.  examine the args
	my $type = $1;
	my $name = $2;
	my $inside = $3;
	$syscall{$num}{name} = $name;
	$syscall{$num}{args} = ();
	if ($inside eq "void") {
	    $syscall{$num}{noargs} = 1;
	}
	else {
	    $inside =~ s/\*/\* /g;
	    my @args = split ',', $inside;
	    my $n = scalar @args;
	    if ($n > 6) {
		$n = 6;
	    }
	    for (my $i=0; $i<$n; $i++) {
		my $arg = $args[$i];
		my @argparts = split ' ', $arg;	    
		# NB: assume prototypes have named args
		my $varname = pop @argparts;
		my $argType = join ' ', @argparts;
		if (exists $syscallStringTypes{$argType}) {
		    # its a string
		    push @{$syscall{$num}{args}}, "string";
		}
		else {
		    push @{$syscall{$num}{args}}, "int";
		}
	    }
	}
    }
}



# examine all the files looking fo info_flow_log_op_write calls

tleek@thompsontwin:~/hg/iferret-logging-new$ find -H . -name "*.[ch]" -print -exec grep "info_flow_log_op_write" '{}' \;  | less

# create the big case stmt for writing syscall log items
open F, ">iferret-syscall-switch.h";
print F "// NB: This code is auto-generated by make_iferret_code.pl. \n";
print F "// It's job is to generate iferret log entries for system calls.\n";
print F "// It should be included in iferret-syscalls.c\n";
print F "switch (EAX) {\n";
for (my $i=0; $i<=$maxSyscallNum; $i++) {
    if (exists $syscall{$i}) {
	print F "case $i: // $syscall{$i}{proto}\n";
	my $numStrings = 1;
	unless (exists $syscall{$i}{noargs}) {
	    my $n = scalar @{$syscall{$i}{args}};
	    for (my $j=0; $j<$n; $j++) {
		my $t = $syscall{$i}{args}[$j];
		if ($t eq "string") {
		    print F "if (copy_string(str$numStrings, $syscallRegArgs[$j])) { \n";
		    $numStrings ++;
		}
	    }
	}
	print F "info_flow_log_syscall_write(scp";
	unless (exists $syscall{$i}{noargs}) {
	    my $n = scalar @{$syscall{$i}{args}};
	    my $numStrings = 1;
	    for (my $j=0; $j<$n; $j++) {
		my $t = $syscall{$i}{args}[$j];
		if ($t eq "string") {
		    print F ",str$numStrings";
		    $numStrings ++;
		}
		else {
		    print F ",$syscallRegArgs[$j]";
		}
	    }
	}
	print F ");\n";
	for (my $j=0; $j<$numStrings-1; $j++) {
	    print F "}\n";
	}
	print F "break; \n";
    }
}
close F;



open F, ">iferret_syscall_arg_fmt.h";
print F "// NB: This code is auto-generated by make_iferret_code.pl. \n";
print F "// It's job is to generate the big array of strings specifying the \n";
print F "// format of iferret log entries for system calls.\n";
print F "\n";
print F "char *iferret_log_format[] = {\n";
for (my $i=0; $i<=$maxSyscallNum; $i++) {
    if (exists $syscall{$i}) {
	print F "  \"";
	if (exists $syscall{$i}{args}) {
	    foreach my $arg (@{$syscall{$i}{args}}) {
		if ($arg eq "int") {
		    print F "i";
		}
		if ($arg eq "string") {
		    print F "s";
		}
	    }
	}
	print F "\"";
	if ($i < $maxSyscallNum) {
	    printf F ",";
	}
	print F " // $syscall{$i}{proto}\n";
    }
}
print F "}\n";

close F;
